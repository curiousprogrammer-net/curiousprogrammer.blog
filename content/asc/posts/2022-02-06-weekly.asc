{
:date "2022-02-06"
:title "Weekly Bits 03/2022 - Grokking Simplicity, Domain modeling, ..."
:layout :post
:tags  ["weekly-bits" "clojure" "aws" "security" "statistics"]
}

:toc:
:toclevels: 4



## Clojure


### Clojure cheatsheet - collections functions: `every?`, `not-every?`, `not-any?`

* every? (hopefully obvious)
+
[source,clojure]
----
(every? pos? [1 0 100])
;;=> false
user> (every? pos? [1 10 100])
;;=> true
----
* not-every? (read *_"at least one that is not"_*)
** it's a complement to `every?`

+
[source,clojure]
----
(not-every? pos? [1 0 100])
;;=> true
(not-every? pos? [1 10 100])
;;=> false
----
* not-any? (read *_"none"_*)
** Note: any? is a completely different predicate (it's not really a collection functionreturns true for _any_ argument, including nil)

+
[source,clojure]
----
(not-any? pos? [-1 0 -100])
;;=> true
user> (not-any? pos? [-1 0 100])
;;=> false
----


### PF.tv Domain Modeling series

452: Domain Invariants https://purelyfunctional.tv/issues/purelyfunctional-tv-newsletter-452-domain-invariants/
* domain model consists of information, operations, and invariants
* some places to encode invariants: types, (property-based) tests, language features, data structures, runtime checks / assertions, documentation, proofs
453: Model as Toy https://purelyfunctional.tv/issues/purelyfunctional-tv-newsletter-453-model-as-toy/
*  just write it [the model] down - the earlier the better (to spot the problems)
* you have a model anyway, it's just often ad hoc and partically written 


## Coda Hale, Dan McKinley and Finite State Machines (and more)

Through the
[https://blog.skyliner.io/fourteen-months-with-clojure-beb8b3e4bf00[Fourteen Months with Clojure]
blog post (which wasn't that interesting for me)
I discovered a few interesting posts by Coda Hale and Dan McKinley (see also http://datadriven.club/[Data Driven Products]).

### https://blog.skyliner.io/on-the-difficulty-of-conjuring-up-a-dryad-16e33e71b055[On The Difficulty Of Conjuring Up A Dryad]

Talks about 3 interesting topics:

1. *A Finite-State Machine*
** One of their earliest major design decision was to model the Skyliner deploy process as a Finite-State Machine (FSM), with transitions from one state to another associated with specific conditions and actions. 
** For example, a deploy in the rollout-wait state will check the newly-launched instances of the deploy. 
*** If the instances are up and running, the deploy is advanced via rollout-ok to the evaluate-wait state. 
*** If the instances have failed to launch, the deploy is advanced via rollout-failed to the rollback state. 
*** If the instances are still launching, the deploy is kept in the rollout-wait state via rollout-in-progress.

2. *A Reliable Coordinator* (Amazon SQS)
SQS has a very robust model for dealing with failures: when a consumer polls the server for a new message, it specifies a visibility timeout
    * Similarly, when sending a message to a queue, one can specify a delay
    * We use the delay and the visibility timeouts to create “ticks” for deploys.
        * When a deploy is started, we send an SQS message with the deploy ID, environment, etc. using a delay of e.g. 10 seconds. 
        * After 10 seconds, it becomes visible to a Skyliner background thread, which receives it using a visibility timeout of e.g. 10 seconds. 
            * The thread looks up the deploy’s current state and takes any appropriate action to advance it. 
            * If the deploy has finished, the thread deletes the message from the queue. 
            * Otherwise, the message is left in the queue to reappear after another 10 seconds has passed.

3. *Blue-Green Deploys*
** Instead of modifying servers in-place and hoping nothing goes wrong, we leverage EC2’s elasticity and launch an entirely new set of instances
** roll back by terminating the new instances

### https://blog.skyliner.io/you-cant-have-a-rollback-button-83e914f420d9[You Can’t Have a Rollback Button]
* The fundamental problem with rolling back to an old version is that web applications are not self-contained, and therefore they do not have versions. 
** They have a current state - the application code and everything that it interacts with. Databases, caches, browsers, and concurrently-running copies of itself.
* One example of the problem - corrupting a cache (simple rollback might not fix the cache)
* Takeaway: favor feature flags (disable them if there's a problem) and roll forward (reverting a smaller diff instead of trying to revert all the other changes that were also released with/since the problematic change)



## Java / JVM



## AWS & Cloud



## Books

### https://github.com/jumarko/grokking-simplicity[Grokking Simplicity] - Introduction

* reading the intro, skimming the book and the first chapter
* two main ideas/skills: 
    * distinguishing actions, calculations, data
    * using first-class abstractions such as higher-order functions (powerful technique for reuse to pass functions to other functions)


### https://github.com/jumarko/api-security-in-action[Api Security in Action] - HMAC & Timing attacks

API Security in Action (book) -> p.172-176
* a simple hash is stored in the database and HMAC tag is appended to the token
* the token-hash.tag is given to the client and tag is computed for every request
/* token generation */
tag = hmac(tokenId)
// return this token to the user; store tokenId in the DB
userToken = tokenId + "." + Base64.encode(tag)

/* request veritification */
providedTag = Base64.decode(token.substringAfter("."))
computedTag = hmac(realTokenId)
// using MessageDigest prevents timing attacks
if (!MessageDigest.isEqual(providedTag, computedTag) {
   // invalid tag -> return/throw without querying the DB
}
...
* invalid requests which produce an invalid tag are rejected immediately without DB query => avoiding timing attacks
    * make sure to use MessageDigest.isEqual to compare the expected and the computed HMAC tag
* token (SQL) injection is prevented because an attacker cannot produce a valid hash even if they have access to the database (they don't have the secret key)


### https://www.amazon.com/Practical-Monitoring-Effective-Strategies-World/dp/1491957352[Practical Monitoring] - Basic statistics

Chapter 4 in the book is short but _practical_ (as the whole book even though it focuses on principles and not particular tools).

* It's a quick tour of the most basic statistics like mean, median, and percentiles.
* It says that *standard deviation is rarely useful* because we mostly deal with not-normal distributions (_skew_)
* It also talks about an important statistical concept, *seasonability* - repeating patterns like a weekly cpu usage.
* Advise to look for *_skew_*, *_outliers*_, and *_bounds*_ when thinking about your data


### https://fiftyquickideas.com/fifty-quick-ideas-to-improve-your-user-stories/[50 Quick Ideas to improve your user stories]


## Writing



## MISC

### PurePerformance podcast

https://www.dynatrace.com/news/pureperformance/


## Links

A quick recap of some of the links mentioned in this post:

* 




