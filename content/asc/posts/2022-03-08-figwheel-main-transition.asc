{
:date "2022-03-08"
:title "Transforming an old project from lein-figwheel to figwheel-main"
:layout :post
:tags  ["clojure" "leiningen" "clojurescript" "frontend"]
}

:toc:

Recently, I went trough the process of upgrading a rather old project using ClojureScript with
https://github.com/bhauman/lein-figwheel[lein-figwheel^]
to https://github.com/bhauman/figwheel-main[figwheel-main^].

It was a painful experience and I struggled a lot.
Hereby, I describe various problems I came across.


## Setting the stage

It all started because I couldn't fire up figwheel build anymore:

[source]
----
1. Unhandled java.util.MissingResourceException
   Can't find resource for bundle java.util.PropertyResourceBundle, key jsdoc.primitives

       ResourceBundle.java:  564  java.util.ResourceBundle/getObject
       ResourceBundle.java:  521  java.util.ResourceBundle/getString
         ParserRunner.java:  116  com.google.javascript.jscomp.parsing.ParserRunner/initResourceConfig
         ParserRunner.java:   78  com.google.javascript.jscomp.parsing.ParserRunner/createConfig
             Compiler.java: 2686  com.google.javascript.jscomp.Compiler/createConfig
             Compiler.java: 2667  com.google.javascript.jscomp.Compiler/getParserConfig
                JsAst.java:  155  com.google.javascript.jscomp.JsAst/parse
                JsAst.java:   55  com.google.javascript.jscomp.JsAst/getAstRoot
               externs.clj:  169  cljs.externs/parse-externs
               externs.clj:  156  cljs.externs/parse-externs
               externs.clj:  204  cljs.externs/externs-map*/fn
...
                  env.cljc:   51  cljs.env$default_compiler_env_STAR_/invokeStatic
                  env.cljc:   46  cljs.env$default_compiler_env_STAR_/invoke
                  env.cljc:   62  cljs.env$default_compiler_env/invokeStatic
                  env.cljc:   59  cljs.env$default_compiler_env/invoke
                 utils.clj:  108  figwheel-sidecar.utils/compiler-env
                 utils.clj:  105  figwheel-sidecar.utils/compiler-env
           build_utils.clj:    8  figwheel-sidecar.build-utils/add-compiler-env
----

After upgrading to latest clojurescript it still failed but in a different way:

[source]
----
Caused by: java.lang.NoSuchMethodError: 'java.util.stream.Collector com.google.common.collect.ImmutableSortedSet.toImmutableSortedSet(java.util.Comparator)'
    at com.google.javascript.jscomp.deps.ModuleLoader.createRootPaths(ModuleLoader.java:257)
    at com.google.javascript.jscomp.deps.ModuleLoader.<init>(ModuleLoader.java:147)
    at com.google.javascript.jscomp.deps.ModuleLoader.<init>(ModuleLoader.java:48)
    at com.google.javascript.jscomp.deps.ModuleLoader$Builder.build(ModuleLoader.java:139)
    at com.google.javascript.jscomp.deps.ModuleLoader.<clinit>(ModuleLoader.java:408)
    at com.google.javascript.jscomp.DiagnosticGroups.<clinit>(DiagnosticGroups.java:182)
    at cljs.closure__init.load(Unknown Source)
    at cljs.closure__init.<clinit>(Unknown Source)
...
    at cljs.repl$loading__5569__auto____4083.invoke(repl.cljc:9)
    at cljs.repl__init.load(Unknown Source)
    at cljs.repl__init.<clinit>(Unknown Source)
...
    at figwheel_sidecar.repl$eval52111$loading__6737__auto____52112.invoke(repl.clj:1)
----

I tried a few times, but couldn't solve the problem.
I looked at the dependencies - they were all terribly outdated.
Moreover, lein-figwheel had been replaced a long time ago by figwheel-main
So I decided to upgrade the whole project.


## Not so fast.

### Updating dependencies 

Updating the depedencies was straightforward.
I just went through everything in the project.clj file,
looked up the latest versions on clojars.org and used those.

To my surprise there were no major problems caused by the upgrade itself; except the problem with upgrading figwheel.

## The Figwheel problem

figwheel-main is quite different from lein-figwheel.

I checked out https://github.com/bhauman/figwheel-main and https://figwheel.org/
and started sketching out the new configuration for my project.

I struggled a lot and couldn't make a proper config.
For instance, I was really confused by the distinction between
`dev.cljs.edn` and `figwheel-main.edn` configuration files.

On top of that, I hadn't worked with this project and ClojureScript tooling for a few years.


## Back to the basics

Enough! It was time to learn the basics.
Taking a more structured approach and reading
https://figwheel.org/docs/[Figwheel documentation^] step by step helped me a lot.
After reading the first half, the things got much clearer.

I realized that the typical Figwheel configuration might actually be split into 2+ files:

* **`<build-name>.cljs.edn`** for ClojureScript build specific configuration
** Typically, you have at least `dev.cljs.edn`.
** This can also contain Figwheel specific configuration attached as metadata.
* **`figwheel-main.edn`** figwheel specific configuration shared by all the builds


### https://github.com/bhauman/figwheel-main-template[figwheel-main-template^]

What helped me a lot was to try https://github.com/bhauman/figwheel-main-template[figwheel-main-template^]:

[source,bash]
----
lein new figwheel-main hello-world.core -- --reagent
----

Then I examined `project.clj`, `dev.cljs.edn` and `figwheel-main.edn`
to get better understanding how things are wired in a real project.

## Fixing problems - step by step

### lein aliases

First, I didn't get a good idea of the aliases I'm supposed to use.
After checking out the sample `hello-world.core` project I figured out
that I not only need need the "fig" alias but, crucially, also "fig:build":

[source,clojure]
----
  :aliases {"fig" ["trampoline" "run" "-m" "figwheel.main"]
            "fig:build" ["trampoline" "run" "-m" "figwheel.main" "--build" "dev" "--repl"]
            ;; a separate figwheel build is used for optimized build
            "fig:min"   ["run" "-m" "figwheel.main" "-O" "advanced" "--build-once" "min"]
            "fig:test"  ["run" "-m" "figwheel.main" "-co" "test.cljs.edn" "-m" "hello-world.test-runner"]}
----

### Wrong output file name

https://figwheel.org/docs/compile_config.html#the-output-to-option[Figwheel compiler configuration docs^]
incorrectly say that the default `:output-to` (compiled javascript) file name is

[source]
----
target/public/cljs-out/[build-name]-main.js
----

When I tried that, I got 404 Not Found in the browser:

image::/img/2022-03-08-figwheel/figwheel-js-build-not-found.png[figwheel js build file - Not Found]

The proper build file name is actually `[build-name]/main.js` not `[build-name]-main.js`:

[source]
----
target/public/cljs-out/[build-name]/main.js
----

### JS imports

After fixing the build file name, the next error I got (in the browser) was:

[source,bash]
----
Uncaught SyntaxError: Cannot use import statement outside a module   main.js:1

# main.js:1
import {npmDeps} from "./npm_deps.js";
----

I was quite confused for a while and searched around
but https://stackoverflow.com/questions/62940050/javascript-modules-syntaxerror-cannot-use-import-statement-outside-a-module[couldn't find much^].

Originally, the project used
https://github.com/yogthos/Selmer#script[Selmer's `script` tag^]
to import JavaScript files.
After looking at the hello-world.core sample project I simply adopted the <script> tag style
used there:

[source,html]
----
    <script type="text/javascript" src="cljs-out/dev/main_bundle.js"></script>
----

I'm not sure why Selmer's `{% script %}` wasn't working.
There may well have been another problem but I didn't find what that was.


### reagent.core vs reagent.dom

The fun was not over. Trying to build it again, I got another error,
this time related to the Reagent's `render` function:

image::/img/2022-03-08-figwheel/reagent-core-render-error.png[reagent.core/render error]

As I said, the project was using really old versions of dependencies
and one of those was `reagent`.
In the new version they simply moved the `render` function from `reagent.core` to `reagent.dom`
so I had to update my main namespace to use `reagent.dom` instead.

I also had to hard-refresh the webpage to get rid of the error.

And the dev build was finally working. Yes!


## Optimized build (for production)

While the build was working in the dev environment
I had to also produce a minimized build for production.
That process brought more surprises.



## Making Figwheel/ClojureScript REPL work with Emacs/Cider

The transition was almost complete but there was one missing piece:
https://figwheel.org/docs/editor-integration.html[editor integration^].

I use Emacs with Cider and being able to interact with the application from within the editor
is an essential part of my development workflow.
I couldn't develop the backend code without it
and I want to have a similar experience on frontend.

Fortunately, Cider has a first-class support for fighweel-main: https://figwheel.org/docs/emacs.html

Unfortunately, it didn't quite work.

### Google Closure compiler and classpath problems

After launching the REPL within Emacs via `cider-jack-in-clj&cljs`),
I got a surprisping error:

[source,clojure]
----
1. Unhandled java.lang.NullPointerException
   Null closurePrimitiveNames

     AutoValue_Config.java:  196  com.google.javascript.jscomp.parsing.AutoValue_Config$Builder/setClosurePrimitiveNames
         ParserRunner.java:   91  com.google.javascript.jscomp.parsing.ParserRunner/createConfig
             Compiler.java: 2686  com.google.javascript.jscomp.Compiler/createConfig
             Compiler.java: 2667  com.google.javascript.jscomp.Compiler/getParserConfig
                JsAst.java:  155  com.google.javascript.jscomp.JsAst/parse
                JsAst.java:   55  com.google.javascript.jscomp.JsAst/getAstRoot
               externs.clj:  169  cljs.externs/parse-externs
----

After trying to find the cause of this error I was becoming desparate.
Until I, by coincidence, clicked on the stacktrace in the Emacs `*cider-error*` buffer.
It opened the corresponding `Compiler.java`.
That wasn't surprising (well, I was a bit surprised that Cider was able to locate the file seamlessly)
but *the weird piece was the file path*:

[source]
----
/Users/jumar/.m2/repository/com/google/javascript/closure-compiler/v20130603/closure-compiler-v20130603-sources.jar:com/google/javascript/jscomp/Compiler.java
----

You'll notice that there was a really old version of `closure-compiler` in place, that is `v20130603`.
But leiningen didn't report the same version - instead it reported much newer `v20200315`:

[source,bash]
----
lein deps :tree >& deps.out && less deps.out
...
 [org.clojure/clojurescript "1.10.773"]
   [com.google.javascript/closure-compiler-unshaded "v20200315"]
----


## Resources

* https://github.com/bhauman/figwheel-main[figwheel-main^]
* https://figwheel.org/docs/[Figwheel documentation^]
* https://github.com/bhauman/figwheel-main-template[figwheel-main-template^]
* https://figwheel.org/docs/editor-integration.html[Figwheel - editor integration^]