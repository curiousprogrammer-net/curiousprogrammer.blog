{
:date "2099-10-13"
:title "Liquibase: custom database migrations with Clojure (without AOT)"
:layout :post
:tags  ["databases" "migrations" "clojure" "leiningen"]
}

:toc:

## Liquibase Intro

https://github.com/liquibase/liquibase[Liquibase^] is a well-know tool for tracking, versioning, and eploying database schema changes.

It uses https://docs.liquibase.com/concepts/introduction-to-liquibase.html[changelog files^]
to list database changes  in the form of https://docs.liquibase.com/concepts/changelogs/changeset.html[changesets^] (SQL, XML, YAML, JSON),
which consists of https://docs.liquibase.com/change-types/home.html[Change Types^].
Standard changsets use SQL or its DB-independent equivalent written in XML, YAML, or JSON.

### Custom migrations

Sometimes, there's a more complicated migration that's very difficult or impossible to define with SQL.
That is, you need to write actual _code_ to perform the migration.
In that case, Liquibase offers https://docs.liquibase.com/change-types/custom-change.html[customChange] Change Type.

To implement a custom migration you need to:

1. Create a Java class that implements the `liquibase.change.custom.CustomSqlChange` or `liquibase.change.custom.CustomTaskChange` interface
+
[source,Java]
----
public class ExampleCustomTaskChange implements CustomTaskChange, CustomTaskRollback {
    private String helloTo;
    @SuppressWarnings({"UnusedDeclaration", "FieldCanBeLocal"})
    private ResourceAccessor resourceAccessor;

    @Override
    public void execute(Database database) throws CustomChangeException {
        Scope.getCurrentScope().getLog(getClass()).info("Hello "+getHelloTo());
    } 
    @Override
    public void rollback(Database database) throws CustomChangeException, RollbackImpossibleException {
        Scope.getCurrentScope().getLog(getClass()).info("Goodbye "+getHelloTo());
    }
    ...
}
----
2. `Compile the created class`, package it into a JAR file, and then add it to a Liquibase classpath.
3. Reference the class in your changelog.
+
[source,bash]
----
...
<changeSet id="21" author="nvoxland">
    <customChange class="liquibase.change.custom.ExampleCustomTaskChange">
        <param name="helloTo" value="world"/>
    </customChange>
</changeSet>
...
----




## Custom migrations in Clojure

Being able to write custom code for db migrations is nice,
but I would really like to write them in Clojure, not Java.
This must be possible!

### AOT

Remember the requirement of referencing the actual class in the customChange tag definition?
This is something we need to preserve.

However, Clojure is a dynamically compiled language which compiles to JVM bytecode on the fly.
Moreover, the class has to implement a specific Java interface, in our case `liquibase.change.custom.CustomTaskChange`.

How do we do that?
One way, is to use https://clojuredocs.org/clojure.core/gen-class[gen-class^]:

[source,clojure]
----
(ns myapp.database.migrations.mig001
  "Migration for renaming column 'value' to 'val'."
  (:require [clojure.java.jdbc :as jdbc])
  (:import (java.sql SQLException)
           (liquibase.exception ValidationErrors)
           (liquibase.database Database)
           (liquibase.structure.core Column)))

(gen-class :name "myapp.database.migrations.Mig001"
           :implements [liquibase.change.custom.CustomTaskChange
                        liquibase.change.custom.CustomTaskRollback])

(defn -getConfirmationMessage [_this] "Renamed value column to val")
(defn -setFileOpener [_this _resourceAccessor] nil)
(defn -setUp [_this] nil)
(defn -validate [_this ^Database _database] (ValidationErrors.))
(defn -rollback [_this ^Database _database] nil)
(defn -execute [_this ^Database database]
  (let [db-spec {:connection (.getUnderlyingConnection (.getConnection database))}
        quote-name (fn [n] (.quoteObject database n Column))]
    (try
      (rename-column db-spec (quote-name "VALUE"))
      (catch SQLException e
        (rename-column db-spec (quote-name "value"))))))
----

Again, we reference the class name in our XML-based changeset definition

[source,xml]
----
    <customChange class="myapp.database.migrations.Mig001" />
----

Then you need to https://clojure.org/reference/compilation[AOT-compile^] it.
It's not too dificult when using https://codeberg.org/leiningen/leiningen/src/commit/64e02a842e7bb50edc9b8b35de1e2ef1fac090dd/sample.project.clj#L273-L280[leiningen^]:

[source,clojure]
----
(defproject myapp ...
...
  ;; DB migrations need always be compiled because the migrator requires Java classes
  :aot [#"^myapp\.database\.migrations\..*"]
...
  ;; the AOT config above is only for development - for uberjar, we AOT-compile everything anyway
  :uberjar {:aot :all
            :omit-source true}
----

Notice we do not want to compile all the classes, just the migrations.

### Problems with AOT

The approach described above works but it's also annoying:

- AOT compilation is automatically performed when we compile the project and it can take a lot of time.
  It's not something that we would normally do when developing the app.
  It's usually enough to do it once - unless you call `lein clean` or otherwise remove the classes compiled into the `target/` directory.
- Whenever we change the migrations code we need to AOT compile it again to make sure Liquibase can use the latest version of our migrations code.
- The code using `gen-class` is quite repetitive and unfriendly.


### Getting rid of AOT (deftype)

Wouldn't it be nice if we could get rid of all the `gen-class` and AOT stuff?

In Clojure, we have mechanisms to implement interfaces via https://clojure.org/reference/datatypes[`deftype`, `defrecord`, and `reify`].

Of these, we cannot use `reify` because it produces an anonymous class and its name changes all the name.
`defrecord` and `deftype` produce a named class.
`defrecord` is more suitable for https://ericnormand.me/mini-guide/deftype-vs-defrecord[domain entities^]
since it also offers a map-like capabilities (see also https://stackoverflow.com/questions/13150568/deftype-vs-defrecord[deftype vs defrecord (StackOverflow)^]).
`deftype`, on the other hand, is more suitable for lower-level programming constructs
where we do not need the additional offerings provided by `defrecord`.

The verdict, then, is to use `deftype`. But how exactly we do that? 

We can keep our XML-based changset definition - although we may want to tweak the class names a bit,
it basically stays the same.

To get rid of the duplication, we may want to introduce a macro

[source,clojure]
----
(ns cacsremoteservice.database.migrations
  (:require
   [myapp.database.migrations.mig001 :as mig001]
   [clojure.java.jdbc :as jdbc]
  (:import
   (liquibase.database.jvm JdbcConnection)
   (liquibase Liquibase Contexts LabelExpression)
   (liquibase.resource ClassLoaderResourceAccessor)))



(defmacro define-reversible-migration
  "Define a reversible custom migration. Both the forward and reverse migrations are defined using the same structure,
  similar to the bodies of multi-arity Clojure functions.

  Example:

  ```clj
  (define-reversible-migration ExampleMigrationName tx
   (migration-body tx)
   (reverse-migration-body tx)))
  ```"
  [name tx-symbol migration-body reverse-migration-body]
  `(deftype ~name []
     liquibase.change.custom.CustomTaskChange
     (execute [_# database#]
       ;; Make the liquibase database object available as `database-anaphora` symbol for more advanced usage
       (let [~'database-anaphora database#]
         (jdbc/with-db-transaction [~tx-symbol {:connection (.getUnderlyingConnection (.getConnection database#))}]
           ~migration-body)))
     (getConfirmationMessage [_#]
       (str "Custom migration: " ~name))
     (setUp [_#])
     (validate [_# _database#]
       (liquibase.exception.ValidationErrors.))
     (setFileOpener [_# _resourceAccessor#])

     liquibase.change.custom.CustomTaskRollback
     (rollback [_# database#]
       (jdbc/with-db-transaction [~tx-symbol {:connection (.getUnderlyingConnection (.getConnection database#))}]
         ~reverse-migration-body))))

(defn no-op
  "No-op logging rollback function"
  [n]
  (log/info "No rollback for: " n))

(defmacro define-migration
  "Define a custom migration without a reverse migration."
  [name tx-symbol & migration-body]
  `(define-reversible-migration ~name ~tx-symbol (do ~@migration-body) (no-op ~(str name))))


;;; The custom migrations
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; note that that class names are referenced in the liquibase XML config files
(define-migration Mig001 tx (mig001/execute tx))
;; => myapp.database.migrations.Mig001->--------

### Classloading gotcha



## Resources

* https://github.com/liquibase/liquibase[Liquibase^]
** https://docs.liquibase.com/concepts/introduction-to-liquibase.html[Introduction to Liquibase^]
** https://docs.liquibase.com/concepts/changelogs/changeset.html[changesets^] (SQL, XML, YAML, JSON)
** https://docs.liquibase.com/change-types/home.html[Change Types^]
** https://docs.liquibase.com/change-types/custom-change.html[customChange] Change Type

* https://clojuredocs.org/clojure.core/gen-class[gen-class^]
* https://clojure.org/reference/compilation[AOT compilation^]
* https://codeberg.org/leiningen/leiningen/src/commit/64e02a842e7bb50edc9b8b35de1e2ef1fac090dd/sample.project.clj#L273-L280[leiningen's :aot config - project.clj]
* https://clojure.org/reference/datatypes[`deftype`, `defrecord`, and `reify`^]
* https://stackoverflow.com/questions/13150568/deftype-vs-defrecord[deftype vs defrecord (StackOverflow)^]
** also https://ericnormand.me/mini-guide/deftype-vs-defrecord[deftype vs defrecord (Eric Normand)^]